package ${tableDefinition.packageName};

import java.io.IOException;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.immutables.value.Value;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.base.Charsets;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.palantir.atlasdb.keyvalue.api.Cell;
import com.palantir.atlasdb.transaction.api.Transaction;

#macro( keysDeclaration )
#foreach($key in $tableDefinition.columnDefinitions.keys)String ${key}#if( $velocityHasNext ), #end#end
#end
#macro( keysUsage )
#foreach($key in $tableDefinition.columnDefinitions.keys)${key}#if( $velocityHasNext ), #end#end
#end

public class ${tableDefinition.generatedClassName} {

    private static final String TABLE_NAME = "${tableDefinition.tableName}";

#foreach($columnDefinition in $tableDefinition.columnDefinitions.columns)
    private static final byte[] ${columnDefinition.columnName.toUpperCase()}_COLUMN = "${columnDefinition.columnShortName}".getBytes(Charsets.UTF_8);
#end

    private final Transaction txn;
    private final ObjectMapper objectMapper;

    public ${tableDefinition.generatedClassName}(Transaction txn) {
        this.txn = txn;
        this.objectMapper = new ObjectMapper(); // TODO: make configurable
    }

#foreach($columnDefinition in $tableDefinition.columnDefinitions.columns)
    public void put${display.capitalize(${columnDefinition.columnName})}(#keysDeclaration(), ${columnDefinition.columnTypeQualifiedName} columnValue) {
        put${display.capitalize(${columnDefinition.columnName})}s(ImmutableMap.of(Key.of(#keysUsage()), columnValue));
    }

    public void put${display.capitalize(${columnDefinition.columnName})}s(Map<Key, ${columnDefinition.columnTypeQualifiedName}> valuesByKey) {
        ImmutableMap.Builder<Cell, byte[]> builder = ImmutableMap.builder();
        for (Entry<Key, ${columnDefinition.columnTypeQualifiedName}> entry : valuesByKey.entrySet()) {
            byte[] column = ${columnDefinition.columnName.toUpperCase()}_COLUMN;
            builder.put(Cell.create(entry.getKey().key(), column), toByteArray(entry.getValue()));
        }
        txn.put(TABLE_NAME, builder.build());
    }

    public ${columnDefinition.columnTypeQualifiedName} get${display.capitalize(${columnDefinition.columnName})}(#keysDeclaration()) {
        Key key = Key.of(#keysUsage());
        return get${display.capitalize(${columnDefinition.columnName})}s(ImmutableSet.of(key)).get(key);
    }

    public Map<Key, ${columnDefinition.columnTypeQualifiedName}> get${display.capitalize(${columnDefinition.columnName})}s(Set<Key> keys) {
        ImmutableSet.Builder<Cell> cells = ImmutableSet.builder();
        for (Key key : keys) {
            cells.add(Cell.create(key.key(), ${columnDefinition.columnName.toUpperCase()}_COLUMN));
        }

        Map<Cell, byte[]> vals = txn.get(TABLE_NAME, cells.build());

        ImmutableMap.Builder<Key, ${columnDefinition.columnTypeQualifiedName}> results = ImmutableMap.builder();
        for (Entry<Cell, byte[]> entry : vals.entrySet()) {
            results.put(Key.from(entry.getKey().getRowName()), toValue(entry.getValue(), ${columnDefinition.columnTypeQualifiedName}.class));
        }

        return results.build();
    }

    public void delete${display.capitalize(${columnDefinition.columnName})}(#keysDeclaration()) {
        Key key = Key.of(#keysUsage());
        delete${display.capitalize(${columnDefinition.columnName})}s(ImmutableSet.of(key));
    }

    public void delete${display.capitalize(${columnDefinition.columnName})}s(Iterable<Key> keys) {
        ImmutableSet.Builder<Cell> cells = ImmutableSet.builder();
        for (Key key : keys) {
            cells.add(Cell.create(key.key(), ${columnDefinition.columnName.toUpperCase()}_COLUMN));
        }
        txn.delete(TABLE_NAME, cells.build());
    }

#end

    private <T> byte[] toByteArray(T val) {
        try {
            return objectMapper.writeValueAsBytes(val);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private <T> T toValue(byte[] arr, Class<T> type) {
        try {
            return objectMapper.readValue(arr, type);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    @Value.Immutable
    public abstract static class Key {
#foreach($key in $tableDefinition.columnDefinitions.keys)
        abstract String get${display.capitalize(${key})}();
#end

        public static Key of(#keysDeclaration()) {
            return ImmutableKey.builder()
#foreach($key in $tableDefinition.columnDefinitions.keys)
                .${key}(${key})
#end
                .build();
        }

#set( $totalBytes = 40 * ${tableDefinition.columnDefinitions.keys.size()} )
        public static final Key from(byte[] arr) {
            Preconditions.checkArgument(arr.length == ${totalBytes}, "length must = ${totalBytes}");
            return ImmutableKey.builder()
#foreach($key in $tableDefinition.columnDefinitions.keys)
                    #set( $startByteIndex = ($velocityCount - 1) * 40 )
                    .${key}(new String(arr, $startByteIndex, 40))
#end
                    .build();
        }

        // TODO: fix this up
        final byte[] key() {
            byte[] key = new byte[$totalBytes];
#foreach($key in $tableDefinition.columnDefinitions.keys)
            #set( $startByteIndex = ($velocityCount - 1) * 40 )
            System.arraycopy(get${display.capitalize(${key})}().getBytes(Charsets.UTF_8), 0, key, $startByteIndex, 40);
#end
            return key;
        }
    }

    @Value.Immutable
    public interface Row {
#foreach($columnDefinition in $tableDefinition.columnDefinitions.columns)
        ${columnDefinition.columnTypeQualifiedName} get${display.capitalize(${columnDefinition.columnName})}();
#end
    }
}